#' Load the Answer Key File for Grading.
#'
#' \code{loadKey()} loads a file with the exam answer key for all versions. This
#' file should be a comma or semicolon separated value file (csv) or a Microsoft
#' Excel file (xls or xlsx) with on its rows the exam versions (e.g. "A", "B",
#' "C", "D") and on its columns the correct responses to the multiple choice
#' test items (questions). The first column specifies the exam version (e.g.
#' "A", "B", "C", "D").
#'
#' @param keyFile A character string specifying the location and name of the csv
#'    or (x)lsx file containing the answer key to the exam items (questions).
#' @return A data.frame object with in the first column the exam version and
#'    the following columns giving the correct answers to the multiple choice
#'    exam test items (questions).
#'
#' @export
#'
#' @examples
#' \dontrun{
#' key <- loadKey(keyFile)}
loadKey <- function(keyFile) {
  validExt <- c("csv", "xls", "xlsx")
  ## Check whether a *.csv, *.xls or *.xlsx has been provided
  if (!(tolower(strsplit(x = keyFile, split = "\\.")[[1]][2]) %in% validExt)) {
    stop("Key not read, due to an invalid key file extension (should be either *.csv, *.xls or *.xlsx)")
  }
  ## Read the correct multiple-choice responses into a data.frame named key
  if (tolower(strsplit(x = keyFile,
                      split = "\\.")[[1]][2]) == validExt[1]) { # a csv-file
    ## Read the *.csv key file into a data.frame named key
    L <- readLines(con = keyFile, n = 1L)
    if (grepl(";", L)) {
      key <- read.csv2(file = keyFile)
    } else {
      key <- read.csv(file = keyFile)
    }
    ## Change all columns of the key data.frame to class character
    for (j in seq_len(ncol(key))) {
      key[, j] <- as.character(key[, j])
    }
  } else {
    if (tolower(strsplit(x = keyFile,
                            split = "\\.")[[1]][2]) %in% validExt[2:3]) { # a xls(x)-file
      ## Read the *.xls(x) workbook file into a structure named wb
      wb <- XLConnect::loadWorkbook(filename = keyFile,
                                    create = FALSE)
      ## Obtain the sheet names in the *.xls(x) workbook as represented by wb
      sheets <- XLConnect::getSheets(object = wb)
      ## Read the first sheet of wb into a data.frame named key
      key <- XLConnect::readWorksheet(object = wb,
                                      sheet = sheets[1],
                                      startRow = 0,
                                      endRow = 0,
                                      startCol = 0,
                                      endCol = 0)
    }
  }
  ## Set row- and column-names in the key data.frame
  rownames(key) <- LETTERS[1:nrow(key)]
  colnames(key) <- c("Version", paste0("I", seq_len(ncol(key) - 1)))
  return(key)
}

#' Load Student Responses to Exam Test Items (Questions).
#'
#' \code{loadResponses()} loads a file with the student responses to the multi-
#' ple choice exam test items (questions). This file should be a FormScanner
#' generated comma or semicolon separated value csv-file or a Microsoft Excel
#' (x)lsx-file generated by Wageningen University & Research ICT/Edusuport, or
#' by means of the \code{\link{formScanner2Excel}} function. The file has on each
#' row: the student registration number, exam version, and the responses to the
#' multiple choice exam test items (questions).
#'
#' @param respFile  A character string specifying the location and name of
#'    the csv or (x)lsx file containing the student responses to the multiple
#'    choice exam test items (questions).
#' @param noItems An integer, not exceeding 40, specifying the number of multiple
#'    choice exam test items (questions) on the answers sheet to be considered.
#'    If a \code{key} object has been created with the \code{\link{loadKey}}
#'    function prior to using the \code{loadResponses} function the \code{noItems}
#'    function argument repuires no specification and will created automatically.
#' @return A data.frame object with in the first column the student registration
#'    numbers of students taking the exam. The second column specifies the exam
#'    version the student filled. Subsequent columns give the filled in answers
#'    to the multiple choice exam test items (questions) as filled by the
#'    students, with a maximum of 40 test items (questions).
#'
#' @export
#'
#' @examples
#' \dontrun{
#' responses <- loadResponses(respFile)}
loadResponses <- function(respFile, noItems = ncol(key) - 1) {
  validExt <- c("csv", "xls", "xlsx")
  ## Check whether a *.csv, *.xls or *.xlsx has been provided
  if (!(tolower(strsplit(x = respFile,
                         split = "\\.")[[1]][2]) %in% validExt)) {
    stop("Responses not read, due to an invalid responses file extension (should be either *.csv, *.xls or *.xlsx)")
  }
  ## Read the student multiple-choice responses into a data.frame named responses
  if (tolower(strsplit(x = respFile,
                       split = "\\.")[[1]][2]) == validExt[1]) { # a csv-file
    ## Read the *.csv responses file into a data.frame named responses
    L <- readLines(con = respFile,
                   n = 1L)
    if (grepl(";", L)) {
      responses <- read.csv2(file = respFile)
    } else {
      responses <- read.csv(file = respFile)
    }
    ## Order by responses$File.name
    responses <- responses[order(responses$File.name), ]
    ## Generate the student registration number (regNumber) from columns ID_NO_001:ID_NO_012
    responses <- tidyr::unite(data = responses,
                              col = regNumber,
                              X.IDStudent..IDNo001:X.IDStudent..IDNo012,
                              sep = "",
                              remove = TRUE)
    ## Select the columns regNumber, Version and the student responses to the
    ## test items (questions)
    responses <- dplyr::select(responses,
                               regNumber,
                               X.Exam..Version,
                               grep("^X\\.Q", colnames(responses)))
    ## Select the columns "regNumber", "Version" and item responses equal to
    ## noItems in the key.
    responses <- responses[, seq_len(2 + noItems)]
    ## Change all columns of the responses data.frame to character
    for (j in seq_len(ncol(responses))) {
      responses[, j] <- as.character(responses[, j])
    }
    ## Fill empty fields with "BLANK"
    responses[!is.na(responses) & responses == ""] <- "BLANK"
  } else {
    if (tolower(strsplit(x = respFile,
                         split = "\\.")[[1]][2]) %in% validExt[2:3]) { # a xls(x)-file
    ## Read the *.xls(x) workbook file into a structure named wb
    wb <- XLConnect::loadWorkbook(filename = respFile,
                                  create = FALSE)
    ## Obtain the sheet names in the *.xls(x) workbook as represented by wb
    sheets <- XLConnect::getSheets(object = wb)
    ## Read the first sheet of wb into a data.frame named responses
    responses <- XLConnect::readWorksheet(object = wb,
                                          sheet = sheets[1],
                                          startRow = 0,
                                          endRow = 0,
                                          startCol = 0,
                                          endCol = 0)
    }
  }
  ## Change column names
  colnames(responses) <- c("Reg. number", "Version", paste0("I", seq_len(noItems)))
  return(responses)
}
